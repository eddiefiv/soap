import requests
import json
import asyncio
import uuid
import websockets
import jsonpickle
import threading
import time

from urllib import parse

from multiprocessing import Queue
# from queue import Queue

from utils.helpers.agent_helpers import get_inference_config, validate_endpoint
from utils.helpers.worker_helpers import SingleInstruction, MultiInstruction
from utils.helpers.all_helpers import create_ws_message
from utils.helpers.constants import HTTPMethod, WorkerState, WorkerTask

from utils.console import *

from worker import Worker

class Agent():
    '''An :class:`Agent` employs :class:`Worker`'s that carry out their given task.
    Typically, the :class:`Agent` is where the inferencing takes place and the
    worker is the scripting that carries out the action generated by the :class:`Agent` response.
    An :class:`Agent` must be attached to a Node in order to receive instruction, this can be done
    by calling `.attach_agent()` on the parent :class:`Node`.'''

    workers = []

    def __init__(self, uses_inference_endpoint = True, inference_endpoint = "http://localhost:5001", uid = "", agent_task_queue: Queue = None) -> None:
        self._uses_inference_endpoint = uses_inference_endpoint
        self._inference_endpoint = inference_endpoint
        self._inference_config = get_inference_config()
        self.agent_id = uid.hex if uid != "" else uuid.uuid4().hex
        self.is_valid = validate_endpoint(inference_endpoint) # Is the endpoint a valid and reachable endpoint. If false, the endpoint may be incorrectly written or not open
        self.agent_name = f"Agent-{self.agent_id}"
        self.agent_task_queue = agent_task_queue
        self.task_queue = Queue()

    async def start(self):
        '''Starts the :class:`Agent` and beings listening for instruction on the localhost server.
        Wont be able to send messages to the websocket server without having received a message first that prompts a sent message.
        Must be ran in order to give tasks to :class:`Worker`'s'''
        async for ws in websockets.connect("ws://localhost:5002", ping_interval = None):
            try:
                self.ws = ws
                #hb = threading.Thread(target = self.sync_heartbeat, args = (ws, 2)) # Start the heartbeating thread to keep this connection alive
                #hb.start()

                await ws.send(create_ws_message(type = "agent_ready", origin = self.agent_name, target = "node")) # Let the node know that this agent is ready to begin tasking
                print_substep(f"{self.agent_name}: Ready to receive instruction from Node!", style = "green1")
                async for message in ws:
                    try:
                        print("Listening...")
                        print(message)
                        res = json.loads(message)
                        print(type(res))
                        print(res['type'])

                        # Maybe create a new thread to parse and run workers if the websocket keeps cutting out during task awaiting
                        await self._parse(message)
                    except Exception as e:
                        print_error(f"{type(e)}: {e}")
                        ws.close()
                        #self.start # Try to notify Node somehow for a more graceful shutdown
            except websockets.ConnectionClosed as e: # Handle spontaneous disconnects and reconnect when occurred
                continue

    def sync_start(self):
        '''Starts the :class:`Agent` and beings listening for instruction on the localhost server.
        Wont be able to send messages to the websocket server without having received a message first that prompts a sent message.
        Must be ran in order to give tasks to :class:`Worker`'s'''
        loop = asyncio.new_event_loop()
        asyncio.set_event_loop(loop)
        loop.run_until_complete(self.start())
        loop.close()

    def sync_heartbeat(self, ws, interval):
        '''Run a heartbeat to keep the WebSocket client alive while working on a task or parsing a new message.
        The heartbeat will run on :class:`Agent` creation, and ends when the :class:`Agent` is destroyed.'''
        loop = asyncio.new_event_loop()
        asyncio.set_event_loop(loop)
        loop.run_until_complete(self.heartbeat(ws, interval))
        loop.close()

    async def heartbeat(self, ws, interval):
        '''Run a heartbeat to keep the WebSocket client alive while working on a task or parsing a new message.
        The heartbeat will run on :class:`Agent` creation, and ends when the :class:`Agent` is destroyed.'''
        while True:
            print_substep(f"{self.agent_name}: Sending heartbeat.", style = "bright_blue")
            try:
                await ws.send(create_ws_message(type = "heartbeat", origin = self.agent_name, target = "node", data = {}))
            except:
                print_error("Couldnt send heartbeat. Trying again.")
            time.sleep(interval)

    async def run_dequeue(self):
        '''Grabs the first task from the Agent Task Queue and inferences to split it up into smaller tasks for the :class:`Worker`'s.
        NOTE: :class:`Agent` will NOT receive messages from the localhost during this time. Only when the task has been inferenced and put into
        the Task Queue will it listen again.'''
        print_substep(f"{self.agent_name}: Beginning scanning for tasks in Agent Task Queue...", style = "bright_blue")
        # Wait to get a task from Node
        try:
            task = self.agent_task_queue.get(block = True, timeout = None)

            # NOTE: In production, task would inference on Agent further, then be sent to Workers
            await self.instruct("null", task)
        except Exception as e:
            print_error("Agent Task Queue empty. Didnt retrieve any data.")

    async def flush_agent(self):
        '''Essentially reset the :class:`Agent` after all tasks given are completed. This usually includes after the Agent Task Queue is empty as well.
        Resets: Agent State, '''
        pass

    async def _parse(self, msg):
        if msg['target'] == self.agent_name or msg['target'] == "any_agent":
            if msg['type'] == "function_invoke":
                if msg['data']['function_to_invoke'] == "instruct":
                    self.instruct(prompt = msg['data']['params']['prompt'])
                elif msg['data']['function_to_invoke'] == "_put_queue":
                    _deserialized_item = jsonpickle.decode(msg['data']['params']['item'])
                    self._put_queue(item = _deserialized_item)
            elif msg['type'] == "worker_complete":
                print(f"{msg['origin']} completed their task: {msg['data']['result']}")
            elif msg['type'] == "agent_dequeue":
                await self.run_dequeue()
            elif msg['type'] == "ping":
                print_substep(f"{self.agent_name}: Received ping from {msg['origin']}", style = "bright_blue")
                return True # Maybe send a pong back to the Node. If need be

    def _put_queue(self, item):
        '''Put an item into the Task Queue. Active :class:`Worker`'s will automatically get items out of the Task Queue and run them as they're available.
        Example item: `MultiInstruction([SingleInstruction(WorkerTask.GOTO, "https://google.com"), SingleInstruction(WorkerTask.SCREENSHOT, None)])`'''
        try:
            self.task_queue.put(item, block = False)
        except:
            print_error(text = f"Insertting {item} into Task Queue, failed. It is possible the queue was full, or something else happened. Task aborted.")

    async def instruct(self, prompt: str, task):
        '''Passes on the prompt to the model associated with this :class:`Agent` and waits for a response.
        Don't run this outside of a :class:`Node` just to ensure that no arbitrary inferences get prompted causing potential confusion in the LLM.'''

        #assert self.is_valid, "No valid endpoint provided, please update the endpoint using .update_endpoint() and then .reload_agent()"

        _prompt = "\n### Instruct: \n".join([prompt])
        await self._employ_worker(self, self.task_queue, uuid.uuid4())
        self.task_queue.put(task)
        # TODO
        # if self._uses_inference_endpoint:
        #     _r = self._post(path = "api/v1/generate", body = self._gen_body(_prompt))

        #     return _r

    def update_endpoint(self, new_endpoint: str):
        '''Updates the :class:`Agent`'s endpoint with a new one
        `.refresh_agent()` must be called after setting a new endpoint in order to use the new endpoint'''

        self._inference_endpoint = new_endpoint

    def refresh_agent(self):
        '''Runs validity checks and updates configurations again to ensure the :class:`Agent` is up to date
        Typically only ran after updating something like the endpoint after :class:`Agent` initialization'''

        self.is_valid = validate_endpoint(self._inference_endpoint)

    def on_worker_complete(self, worker: Worker):
        '''Should only be called as a callback function when a :class:`Worker` is complete with their given task'''
        if worker not in self.workers: # If the worker the call was from is not an attached worker
            print("Task completion callback received from unknown Worker. Ignoring completion call.")
        else:
            print(f"Worker: {worker.worker_uuid} completed their task.")

    async def _employ_worker(self, parent_agent, task_queue, uuid):
        '''Initializes a new :class:`Worker` and attaches them to this object'''
        print_substep(f"{self.agent_name}: Employing new Worker with UUID: {uuid}", style = "bright_blue")

        worker = Worker(parent_agent = parent_agent, task_queue = task_queue, uid = uuid)
        self.workers.append(worker)

        _p = threading.Thread(target = worker.sync_start, name = f"Thread-{worker.worker_name}")
        _p.start() # Start the new worker process

    def test(self):
        print("Test process")

    def _gen_body(self, prompt: str):
        if self._inference_config != None:
            _new_config = self._inference_config
            _new_config.update({"prompt:": prompt})

            return _new_config
        else:
            return {"prompt": prompt}

    def _request(self, method: HTTPMethod, path: str, body = None):
        try:
            if type(body) == dict:
                if body != None:
                    _body = json.dumps(body)
                else:
                    _body = None
            elif type(body) == str:
                _body = body
            else:
                raise RuntimeError("(_post) body was not given a valid json string or dict or None")

            if method == HTTPMethod.POST:
                self._post(path, body)
            elif method == HTTPMethod.GET:
                self._get(path, body)
        except Exception as e:
            print_warning(e)

            return False, None

    def _post(self, path: str, body = None):
        _r = True, requests.post(parse.urljoin(self._inference_endpoint, path), data = body)

        return _r

    def _get(self, path: str, body = None):
        _r = True, requests.get(parse.urljoin(self._inference_endpoint, path), data = body)

        return _r

    def __str__(self):
        return self.agent_name